Overview of New CodeThe new and changed code for A2 includes:    The code that manages the MIPS software-managed TLB (in kern/arch/mips/vm).    Most of the code that implements paging -- the mechanism by which memory pages of an active process can be sent to disk or restored to memory (in kern/thread/vm).    Updated header files for this functionality (in kern/include and kern/arch/mips/include). Here is a brief summary of the new files:    kern/vm/vmobj.c - code to manage "virtual memory objects", which define regions of a process's virtual address space.    kern/vm/lpage.c - code to manage "logical pages", the structure that describes each page of the virtual adcdress space. Most of the code you must write will be placed in this file.    kern/vm/swap.c - code to manage the swap area, providing functions to move pages between disk and main memory.    kern/vm/addrspace.c - not new, but completely rewritten to set up and manage a process's virtual address space using the new vmobj and lpage structures.    kern/arch/mips/vm/vm.c - machine dependent part of virtual memory management; this is the starting point when a TLB miss exception occurs.    kern/arch/mips/vm/coremap.c - machine dependent part of memory management responsible for the allocation / reclamation of physical pages of memory. The functions that select a page to be replaced should be implemented here.    kern/test/coremaptest.c - test of the existing coremap functions. These are invoked as "cm" and "cm2" from the os161 menu promptTo help you get started, base-design.txt describes the overall design of the virtual memory system that you will be completing. You should read this file before starting to read the code.Assignment TasksYour mission is to implement missing functions in kern/vm/lpage.c and kern/arch/mips/vm/coremap.c that handle page faults:    lpage_fault --- handles a page fault. (Until you implement this function you won't be able to run any test user programs).    lpage_evict --- evicts an lpage from physical memory.    page_replace --- implements page replacement policy. You will write two versions of this function.page_replaceYou will write both a sequential page replacement algorithm and a random replacement algorithm. The sequential replacement algorithm should keep track of the last page evicted from the coremap so that the next entry in the coremap can be evicted in turn. Use the ASST2-RAND configuration file to build a version of the kernel that uses the random replacement algorithm and the ASST2-NORAND configuration file to build the version that uses sequential eviction.You should code and debug your implementation of sequential page replacement before using random eviction to test your code more thoroughly. You do not need to worry about giving preference to clean pages over dirty ones in either page replacement algorithm.Paging DetailsAs covered in the lecture notes, the kernel creates the illusion of unlimited memory by using physical memory as a cache of virtual pages. Paging relaxes the requirement that all the pages in a process's virtual address space be in physical memory. Instead, we allow a process to have pages either on disk or in memory. When a process tries to access a page that is on disk (and not in physical memory), a page fault occurs. The kernel must retrieve the page from disk and load it into memory. Pages with valid TLB entries are located in physical memory. This means that a reference to a page on disk (and not in memory) will always generate a TLB fault. At the time of a TLB fault, the hardware generates a TLB exception, trapping to the kernel. The operating system then checks its page table to locate the virtual page requested. If that page is currently in memory but wasn't mapped by the TLB, then the kernel need only update the TLB. However, if the page is on disk, the kernel must:    Allocate a frame in physical memory to store the page;    Read the page from disk;    Update the page table entry with the new virtual-to-physical address translation;    Update the TLB to contain the new translation; and    Resume execution of the user program (at least put it on the ready queue).In os161, this is handled simply by returning from the TLB exception.Notice that when the operating system selects a location in physical memory in which to place the new page, that location may already be occupied by another page. In this case, the operating system must evict that other page from memory. If the page has been modified or is not present in the swap area on disk, then the page being evicted must be written to disk before the physical page can be reallocated to the new page (the one that generated the page fault above). If the page being evicted has not been modified and is already present in the swap area on disk, then the kernel can avoid writing the page to disk, but the appropriate page table entry still must be updated to reflect the fact that the evicted page is no longer in memory.The first access to a part of the virtual address space that is not loaded from the executable file (e.g. the first access to a page in the stack or the heap) is treated as a special case. These pages are not present in memory, but they have no representation on disk either. In this case, the OS simply allocates a physical page and zeros the contents before updating the page table and the TLB.This is often referred to as a "zero fill" page.As with any caching system, performance of your virtual memory system depends on the policy used to decide which things are kept in memory and which are evicted. On a page fault, the kernel must decide which page to replace. Ideally, it will evict a page that will not be needed soon. Many operating systems (such as UNIX) avoid the delay of synchronously writing memory pages to disk on a page fault by writing modified pages to disk in advance, so that subsequent page faults can be completed more quickly. (You do not need to implement this optimization in this assignment.)Paging in OS/161To complete the virtual memory system, you will write the function that handles page faults (lpage_fault) and some of the functions it calls. When you have completed this problem, your system will be able to handle the exception that is generated when a process tries to access an address that is not memory-resident. After handling the exception, the system can continue running the user process.You do not need to implement functions to move a page from disk to memory and from memory to disk (see kern/vm/swap.c). However, you should make sure you understand how the backing store is implemented. (The backing store is the place on disk where you store virtual pages not currently stored in physical memory - i.e. swap space). How are evicted pages stored and how are they found when needed?When the time comes to bring a page into memory, you will need to know which physical pages are currently in use. One way to manage physical memory is to maintain a core map, a sort of reverse page table. Instead of being indexed by virtual addresses, a core map is indexed by its physical page number and contains the virtual address and address space identifier for the virtual page currently backed by the page in physical memory. When you need to evict a page, you look up the physical address in the core map, locate the address space whose page you are evicting and modify the corresponding state information to indicate that the page will no longer be in memory. Then you can evict the page. If the page is dirty, it must first be written to the backing store.The file kern/arch/mips/include/coremap.h defines the coremap data structure which tracks the use of physical memory pages (implemented in kern/arch/mips/vm/coremap.c).Your paging system must support page allocation requests generated by kmalloc(), as well as from user programs. This code is already implemented for you. However, remember that kernel pages cannot be paged out. Why not?Although we are discarding the dumbvm implementation for this assignment, you may find it worth looking at its code, especially vm_fault(). Although it is simple, it should give you some useful insight into how other parts of the code work.Testing will be difficult in this assignment. You will need to create a number of user programs that create large arrays of memory and access them in predictable ways, so you can evaluate whether pages are being paged in and out appropriately. Some of the existing test programs in src/user/testbin/ can be used for this. In particular, you should try: huge, matmult, palin, and sort. To test synchronization, you need to be running multiple processes that all use memory. The existing triple* test programs do this, but depend on the execv system call, which is not implemented. You should be able to create similar tests that just fork several child processes, each of which executes the matmult or sort function separately, however. 