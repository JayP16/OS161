A3 New CodeBy now you have put significant effort into your kernel, so we are allowing you to choose your starting point for this assignment. You can work with your a2 or a3 kernel, if you want to keep your fork / pid management implementation, debug statements that you have added to the code, virtual memory system and any other modifications that you have made.We are providing a set of new files to get you started on the assignment. These include a pseudo shell (described in a later section) in the src/user/bin/psh directory and a few other changes:    kern/arch/mips/syscall/syscall.c - main dispatch code for the system calls you have to handle    kern/include/syscall.h - now including prototypes for the file system call handler functions    kern/syscall/file_syscalls.c - new version with headers for all the file system related system calls you will implement    kern/syscall/file.c - barebones scaffolding code related to handling open files. See also kern/include/file.h for the definitions of the file table structures.    kern/include/thread.h and kern/thread/thread.c - added a filetable field to the thread struct and initialized it to NULL on thread startup    kern/fs/sfs/ - implementation of the "simple file system"    user/sbin/mksfs - user-level utility program to initialize a new SFS file system (the build also generates a version that can be run on the host system).    user/sbin/dumpsfs - user-level utility to dump the contents of an SFS file system on a disk (also comes with a host version)    user/sbin/sfsck - user-level utility to check an sfs file system for consistency (also comes with a host version)If you choose to work with your own kernel, you will need to integrate the changes in these files with your existing code manually (all relevant code changes are marked with "/* BEGIN ASST3 SETUP */" and "/* END ASST3 SETUP */" comments to make it easy to locate). We are also providing a full kernel tree, based on the a3 starter code with these additions already incorporated.The ASST3 config file is set up to use DUMBVM again, but you should be able to use your VM solution from ASST3 if you wish, and just change the ASST3 config file to not use DUMBVM.Assignment TasksYour primary goals are to complete a set of file-system related system calls and to augment SFS with the ability to read directory entries. You will also make SFS use disk space more efficiently.    Open file table (15 pts): A major part of handling file system calls is the design and implementation of the per-process open file table. You must support fork() semantics for the open file table, which may involve changes to the fork() implementation that you were provided. Make sure you read the OS/161 man page for fork().    System Calls (30 pts): Implement 10 new system calls, detailed in the System Calls section. It's not as bad as it sounds -- many of the system calls are paired. open and close, for example.    Reading directory entries (5 pts): The current SFS code does not support the VFS "getdirentry" operation, so you cannot list the files on SFS. You need to implement this operation for SFS.    Using wasted space in SFS inode blocks (5 pts): The current SFS code uses an entire disk block (512 bytes) for an inode, but most of that space is unused. You will modify the SFS code to allow the first part of file data to be stored in the unused space in the file's inodes.    Design Document (5 pts): Make sure to discuss how your design for the open file table supports fork() semantics (a child inherits the open file descriptors of the parent, but has its own file table so that files opened after the fork are not shared). In addition, if you are unable to complete the assignment, include a list of problems remaining in the submission. This document MIGHT replace the code interview for A3, since we do not wish to require you to be available for interviews after the last day of class.Open File Table (15 pts)Although these system calls may seem to be tied to the filesystem, in fact, many of them are really about manipulation of file descriptors, or process-specific filesystem state. We have designed part of this system for you, in syscall/file.c. Some of this information (such as the current working directory) is specific only to the process, but others (such as the file offset) is specific to the process and file descriptor. Think carefully about the state you need to maintain, how to organize it, and when and how it has to change. Think carefully also about what is shared when a process forks, and what happens when a file is closed in the parent or the child (or both).For any given process, the first file descriptors (0, 1, and 2) are considered to be standard input (stdin), standard output (stdout), and standard error (stderr). These file descriptors should start out attached to the console device ("con:"), but your implementation must allow programs to use dup2() to change them to point elsewhere. You need to ensure that these are initialized correctly as part of starting up a user process (refer to kern/syscall/runprogram.c).New System Calls (30 pts)Add support for the system calls listed below. Some of these deal only with managing file system state, while others operate on the file system itself. Read the OS/161 man pages for these system calls for details on their arguments and operation before starting to implement them.    open, close, dup2    read, write, lseek    chdir, getcwd    fstat, getdirentry, Managing per-process file system stateopen(), close(), dup2, read(), write(), lseek(), chdir(), and getcwd()You will likely find it useful to look at the console I/O setup provided for A3 and the simple versions of sys_read() and sys_write() to help you get started with implementing these system calls. (refer to kern/syscall/file_syscalls.c)Managing file systemsgetdirentry(), fstat()The remaining system calls read the state of the file system itself. Mainly, these calls can be handled by calling the appropriate VFS functions (after checking for errors with arguments provided by users!). The getdirentry call, however, will get an error code returned by the SFS layer until the implementation of this function is complete.For this part of the assignment, the system calls should be considered complete when they handle checks for user errors, call the correct lower-level function, and return suitable results or error codes to the user level. If the lower file system layers do not implement the functionality that the system call requires to perform correctly, that is okay. Extensions to the SFS file system will be dealt with in the next part of the assignment.Error Code GuidelinesThe general requirements for error codes are detailed in the OS/161 man pages. Specific requirements:    If a file or directory is expected to exist by the semantics of a call, and it does not, the resulting error code should be ENOENT.    If a file is encountered where a directory was expected, the resulting error code should be ENOTDIR.    If a directory is encountered where a file was expected, the resulting error code should be EISDIR.    If an operation cannot be completed because the disk is full, the resulting error code should be ENOSPC.    If removal of a non-empty directory is attempted, the resulting error code should be ENOTEMPTY.    When an invalid file handle is used, the resulting error code should be EBADF.    If an attempt is made to operate in a prohibited manner upon "." or "..", the resulting error code should be EINVAL. Note that many of these errors cannot be detected within the system call handlers themselves. You should simply check if the corresponding VFS operation succeeds or fails, and return the error from the VFS function on failure. You will need to consider the list of possible errors from the OS161 man pages, and decide which ones can be checked by the system call handler and which ones are the responsibility of the lower-level code.SFS getdirentry implementation (5 pts)For this part of the assignment, you must work below the VFS layer and augment the SFS file system. The main file to look at is kern/fs/sfs/sfs_vnops.c, where the interface functions for the VFS layer are implemented. You will find that the vnode_ops table for directories (sfs_dirops) has UNIMP as the function for getdirentry.Implement a function named sfs_getdirentry and modify the sfs_dirops table to point to it instead of UNIMP. You should review the comments for vop_getdirentry in kern/include/vnode.h, the structure of sfs directory entries in kern/include/kern/sfs.h, the existing sfs_readdir function in kern/fs/sfs/sfs_vnops.c, and the uio functions in kern/include/uio.h and kern/lib/uio.c.Using space in SFS inodes (5 pts)Read the definition of a "struct sfs_inode" in kern/include/kern/sfs.h. It is designed to occupy exactly one disk block. This design has some advantages over the Unix File System design -- an inode number can simply be its disk block number, and there is no fixed limit on the number of inodes in the file system. The downside is that it is very wasteful of space. There are only 60 bytes of information in the inode (12 direct block pointers = 48 bytes, 1 indirect block pointer = 4 bytes, 4 bytes for size, 2 bytes for type and 2 bytes for linkcount), with the rest allocated to the "sfi_waste" field.This wasted space can be used to store the first part of the file data. Modify the sfs_inode structure to include a field "char sfi_inlinedata[SFS_INLINED_BYTES]" and modify the code in sfs_vnops.c to store the first SFS_INLINED_BYTES of file data in the inode itself. Note that we have defined SFS_INLINED_BYTES for you in kern/include/kern/sfs.h to be a multiple of the directory entry size, so the same changes should work for storing the first few directory entries in the inode. There may still be some wasted space in the inode -- make sure that the sizeof(struct sfs_inode) is still 512 bytes when you have made your changes!Tips:    This change really only affects the way that an offset in the file is translated to an address on the disk. For example, currently offset 0 in the file corresponds to offset 0 in the disk block whose address is stored in sfi_direct[0]. That is, it is the first byte in the first data block. When we inline some data into the inode, offset 0 in the file will be the first byte of the new sfi_inlinedata field in the inode. Similarly, the first byte of the first data block will now be at offset SFS_INLINE_DATA in the file. Read the sfs_io() function in sfs_vnops.c to see how file offsets are currently mapped to offsets in disk blocks, and make the necessary changes there. (check for comments in sfs_vnops.c that indicate where changes are likely to be needed)    Modified inodes must be marked dirty so that they are written back to disk during a sync operation. Make sure that you mark the inode dirty if there are any writes to the new data region in an inode.    You will also need to consider how this change affects truncating a file to a new length. Read and modify sfs_truncate() in sfs_vnops.cTesting Your ImplementationThe parts above the VFS layer, and the parts below can mostly be tested independently. The exception is the getdirentry system call, which requires both an implementation of the system call and the underlying sfs_getdirentry function to work together.The SFS design is not "crash consistent", meaning that if the OS crashes (or panics, or is killed with a CTRL-C, or any such unclean shutdown), the state of the file system on disk will be inconsistent. This happens because SFS caches modified file system state in memory until either a sync is called, or the file system is unmounted -- these modifications are lost when there is a crash. IThe best thing to do is to re-initialize the file system on your DISK file (using hostbin/host-mksfs) whenever the system crashes, since you cannot trust the state of the file system on that disk otherwise.In addition to hostbin/host-mksfs, there are two other utility programs that might come in handy: hostbin/host-dumpsfs will dump the file system stored on the specified DISK, showing the state of the free space bitmaps and the directory entries. To remain useful, however, it needs to be updated to know about directory entries that might be stored in the directory inode itself. The same is true for hostbin/host-sfsck, which checks a file system on disk for consistency and corrects what problems it can.System calls:Your code-base does not include execv, nor does the "p" command allow arguments to be passed. Instead, /src/bin contains a new command named psh (pseudo-shell) that will allow you to run the file system programs ls.c, cp.c, cat.c with arguments. It is a pseudo shell because it does not fork and exec a new process when you type in a command. Instead, it simply calls the function that implements each program.Note that the pseudo-shell may not work until you have implemented the read system call, so that it can read commands that you enter at the console. We have left the "dumb" console-only versions of sys_read and sys_write in place, to facilitate early testing, but these should be replaced with versions that use the file table and work for all file descriptors. Your submission should remove all use of "dumb_console_IO" including the call to bootstrap this in kern/startup/main.c We have also provided a cheap hack to synchronize the menu thread with the thread forked to run the pseudo-shell process (or other user-level processes), so that characters you type are read by the shell (or other process) and not by the OS161 menu thread. If you do not have a working pid_join() implementation from A1, you can use this simple synchronization strategy. (We create a semaphore with initial value of 0; the menu thread does a P() on this semaphore and the program thread does a V() when it exits.)You may also find the following programs in testbin useful: badcall, bigfile, conman, dirseek, filetest, hash, sink, tail. You should run these directly from the OS/161 prompt -- not through psh. Several of these will need some modification: dirseek attempts to create a subdirectory on SFS for testing, but you are not implementing mkdir; filetest, hash, and tail expect arguments such as a file name but argument passing to user programs is only available if you have your A1 solution (you can hardcode the arguments for individual tests).Using inode for dataThe built-in file system tests, fs[1-5], can be used from the OS/161 menu prompt. They work on the starter code for SFS, and should continue to work when you have made your changes.RequirementsWe will test your implementation by running the file system commands we have provided to you for psh, as well as the fs tests from the menu. Make sure your implementation supports as many of these operations as possible. If it cannot support all of them, please note how complete your solution is in your design document.Design DocumentYour design document should address the following topics:    Explain how your open file table design supports the fork semantics.    Explain your implementation of sfs_getdirentry.    Explain what changes you needed to make to use wasted inode space to store file data.    Discuss the single biggest challenge you had to address for the assignment